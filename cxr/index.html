<head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161484045-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161484045-1');
</script>


<link rel="stylesheet" href="site.css" />

<!-- Load opencv.js -->
<script src="thirdparty/opencv.js"> </script>

<!-- Load TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.0"> </script>

<!-- Load thirdparty -->
<script src="thirdparty/base64-binary.js"> </script>
<script src="thirdparty/dropzone.min.js"> </script>
<script src="thirdparty/FileSaver-v2.0.2.min.js"> </script>
<script src="thirdparty/jszip.min.js"> </script>
<link rel="stylesheet" href="thirdparty/dropzone.min.css"/>


<!-- Load our util (shared with worker) -->
<script src="util.js"> </script>

</head>

<body>

<div id="page">

<h1>Chest X Ray QC (prototype)</h1>
<p>For informational use only. Not validated for any purpose.</p>

<img id="cxrLogo" src="skeleton.svg" width=100 height=100></img>

<h2 id="cxrStatus"></h2>

<form action="/file-upload"
      class="dropzone"
      id="cxrDropzone">
  <p class="dz-message">Drop chest X ray image here, or click to upload</p>
</form>

<div id="cxrResults"></div>

<!-- for testing
<img id="cxrImage" hidden=true width=1024 height=1024></img>
<img id="cxrCanvas" hidden=true width=1024 height=1024></img>
 -->
<img id="cxrImage" width=1024 height=1024></img>
<canvas id="cxrCanvas" width=1024 height=1024></canvas>


<script>

  if (!window.Worker ||
      !window.tf ) {
    alert("This browser is not supported.  Share X ray photos with a computer that has a modern browser");
  }

  //
  // args and globals
  //
  //const modelName = "CheXNet_acil-tfjs";
  //const modelName = "modeltest-003-0.894167-0.769167.tfjs";
  let modelName = "modeltest-003-0.886000-0.806667.tfjs";
  let modelURL = `https://storage.googleapis.com/cxr-models/${modelName}/model.json`;
  let model;

  const imageElement = document.getElementById('cxrImage');
  const imageCanvas = document.getElementById('cxrCanvas');
  let imageMatrix;
  const imageLogoSource = imageElement.src;
  const dropzoneElement = document.getElementById('cxrDropzone');
  let predictingFile = undefined;
  const filesToProcess = [];
  const filesProcessed = [];
  let offerDownload = false;

  const url = new URL(document.location.href);
  const searchParams = new URLSearchParams(url.search);
  if (searchParams.has("imageURL")) {
    const imageURL = new URL(searchParams.get("imageURL"));
    const pathParts = imageURL.pathname.split("/")
    const name = pathParts[pathParts.length-1];
    predictFromImageSource(name, searchParams.get("imageURL"));
  }
  if (searchParams.has("modelURL")) {
    modelURL = searchParams.get("modelURL");
  }
  if (searchParams.has("offerDownload")) {
    if (searchParams.get("offerDownload") == "true") {
      offerDownload = true;
    }
  }

  //
  // model
  //
  status('Downloading predictive model');
  const modelLoadPromise = tf.loadLayersModel(modelURL, {
    onProgress: (fraction) => {status(`${(fraction * 100).toFixed(1)}% loaded...`);},
  });

  modelLoadPromise
  .then(loadedModel => {
    model = loadedModel;
    status("Model is ready");
    triggerPrediction()
  });


  //
  // file processing and prediction
  //
  function checkAcceptedFiles(file) {
    file = file || {name: "unspecified"};
    dropzone.getAcceptedFiles().forEach(file => {
      if (file.dataURL
            && filesToProcess.indexOf(file) == -1) {
        status(`adding ${file.name}`);
        filesToProcess.unshift(file);
      }
    });
    triggerPrediction();
  }

  function predictFromBase64Image(name, rows, columns, imageString) {
    imageArray = Base64Binary.decode(imageString);
    imageMatrix = cv.matFromArray(rows, columns, cv.CV_8UC3, imageArray);
    cv.imshow('cxrCanvas', imageMatrix);
    predictFromImageSource(name, imageCanvas.toDataURL("image/png"));
  }

  function predictFromImageSource(name, imageSource) {
    imageElement.src = imageSource;
    predictingFile = {
      name: name,
      dataURL: imageElement.src,
    }
    equalizeImageToCanvas()
    .then(predictResultFromCanvas);
  }

  function equalizeImageToCanvas() {
    // uses global element and canvas
    return new Promise((resolve, reject) => {
      imageMatrix = cv.imread(imageElement); // TODO: normalize in cv
      const message = cvImageToMessageData(imageMatrix);
      imageMatrix.delete();
      message.request = "equalize";
      const worker = new Worker("worker.js");
      worker.addEventListener("message", (message) => {
        imageMatrix = messageDataToCvImage(message.data);
        cv.imshow('cxrCanvas', imageMatrix);
        imageMatrix.delete();
        worker.terminate();
        resolve();
      });
      worker.postMessage(message);
    });
  }

  function predictResultFromCanvas() {
    status(`Predicting ${predictingFile.name}...`);
    const tensor = tf.browser.fromPixels(imageCanvas).div(255);
    const reshapedTensor = tensor.reshape([-1, imageElement.height, imageElement.width, 3]);
    predictionTensor = model.predict(reshapedTensor, {verbose: true})
    predictionTensor.data()
    .then(data => {
      finalizePrediction({
        name : predictingFile.name,
        headerText : `Results for: ${predictingFile.name}`,
        thumbnailSoure : predictingFile.dataURL,
        probability : data[1],
      });
      filesProcessed.unshift(predictingFile);
      filesProcessed.unshift(predictingFile);
      predictingFile = undefined;
      status(`Finished predicting`);
      checkAcceptedFiles();
    });
  }

  function finalizePrediction(prediction) {
    // create document structure
    const results = document.getElementById('cxrResults')
    const header = document.createElement("h3");
    results.appendChild(header);
    const reportThumbndail = document.createElement("img");
    results.appendChild(reportThumbndail);
    reportThumbndail.width = 200
    const result = document.createElement("p");
    results.appendChild(result);
    // fill in values
    header.innerText = prediction.headerText;
    reportThumbndail.src = prediction.thumbnailSoure;
    result.innerText = `${(100 * prediction.probability).toFixed(2)}% probability of being a good chest X ray image`;

    if (offerDownload) {
      const resultObject = {
        name: prediction.name,
        probability: prediction.probability,
      };
      imageCanvas.toBlob(pngBlob => {
        const resultBlob = new Blob([JSON.stringify(resultObject, null, 2)], {type: 'application/json'});
        let zip = new JSZip();
        zip.file(`${prediction.name}-result.json`, resultBlob);
        zip.file(`${prediction.name}-equalized.png`, pngBlob);
        zip.generateAsync({type: "blob"})
        .then(contents => {
          console.log(contents);
          saveAs(contents, `${prediction.name}-result.zip`);
        });
      }, 'image/png');
    }
  }

  function triggerPrediction() {
    if (predictingFile
          || filesToProcess.length == 0
          || !model
      ) {
      console.log('triggered, but nothing to predict');
      console.log('predicting', predictingFile);
      console.log('filesToProcess', filesToProcess);
      return;
    }
    const file = filesToProcess.pop();
    predictingFile = file;
    setTimeout(() => {
      imageElement.src = predictingFile.dataURL;
      imageElement.onload = function() {
        dropzone.removeFile(predictingFile);
        status(`Equalizing ${predictingFile.name}...`);
        equalizeImageToCanvas()
        .then(predictResultFromCanvas);
      }
    }, 5);
  }

  function status(message) {
    console.log(message);
    document.getElementById('cxrStatus').innerText = message;
  }

</script>

<script>
//
// code that needs to execute after document body is loaded
//
(function() {
  Dropzone.autoDiscover = false;
  dropzone = new Dropzone(dropzoneElement, {
    autoProcessQueue: true,
    parallelUploads: 1,
  });
  dropzone.on("error", checkAcceptedFiles);
})();
</script>

</body>
