<head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161484045-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161484045-1');
</script>


<link rel="stylesheet" href="site.css" />

<!-- Load opencv.js -->
<script src="thirdparty/opencv.js"> </script>

<!-- Load TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.0"> </script>

<!-- Load thirdparty -->
<script src="thirdparty/base64-binary.js"> </script>
<script src="thirdparty/dropzone.min.js"> </script>
<script src="thirdparty/FileSaver-v2.0.2.min.js"> </script>
<script src="thirdparty/jszip.min.js"> </script>
<link rel="stylesheet" href="thirdparty/dropzone.min.css"/>


<!-- Load our util (shared with worker) -->
<script src="util.js"> </script>

</head>

<body>

<div id="page">

<h1>Chest X Ray QC (prototype)</h1>
<p>For informational use only. Not validated for any purpose.</p>

<img id="cxrLogo" src="skeleton.svg" width=100 height=100></img>

<h2 id="cxrStatus"></h2>

<form action="/file-upload"
      class="dropzone"
      id="cxrDropzone">
  <p class="dz-message">Drop chest X ray image here, or click to upload</p>
</form>

<div id="cxrResults"></div>

<!-- for testing
<img id="cxrImage" hidden=true width=1024 height=1024></img>
<img id="cxrCanvas" hidden=true width=1024 height=1024></img>
 -->
<img id="cxrImage" width=1024 height=1024></img>
<canvas id="cxrCanvas" width=1024 height=1024></canvas>


<script>

  if (!window.Worker ||
      !window.tf ) {
    alert("This browser is not supported.  Share X ray photos with a computer that has a modern browser");
  }

  //
  // args and globals
  //
  //const modelName = "CheXNet_acil-tfjs";
  //const modelName = "modeltest-003-0.894167-0.769167.tfjs";
  //let modelName = "modeltest-003-0.886000-0.806667.tfjs";
  let modelName = "model-009-0.922879-0.799286.tfjs"
  let modelURL = `https://storage.googleapis.com/cxr-models/${modelName}/model.json`;
  let model;

  const cxr = {
    imageElement : document.getElementById('cxrImage'),
    imageCanvas : document.getElementById('cxrCanvas'),
    imageMatrix : undefined,
    dropzoneElement : document.getElementById('cxrDropzone'),
    state : {
      predictingFile : undefined,
      filesToProcess : [],
      filesProcessed : [],
    },
    options : {
      offerDownload : false,
    },
  };
  cxr.imageElement.crossOrigin = "Anonymous";

  const url = new URL(document.location.href);
  const searchParams = new URLSearchParams(url.search);
  if (searchParams.has("imageURL")) {
    // for example:
    // http://127.0.0.1:8080/?imageURL=https://storage.googleapis.com/cxr-data/chest-xray/test/PNEUMONIA/person100_bacteria_475.jpeg&offerDownload=true
    const imageURL = new URL(searchParams.get("imageURL"));
    const pathParts = imageURL.pathname.split("/")
    const name = pathParts[pathParts.length-1];
    predictFromImageSource(name, searchParams.get("imageURL"));
  }
  if (searchParams.has("modelURL")) {
    modelURL = searchParams.get("modelURL");
  }
  if (searchParams.has("offerDownload")) {
    if (searchParams.get("offerDownload") == "true") {
      cxr.options.offerDownload = true;
    }
  }

  //
  // model
  //
  status('Downloading predictive model');
  const modelLoadPromise = tf.loadLayersModel(modelURL, {
    onProgress: (fraction) => {status(`${(fraction * 100).toFixed(1)}% loaded...`);},
  });

  modelLoadPromise
  .then(loadedModel => {
    model = loadedModel;
    status("Model is ready");
    triggerPrediction()
  });


  //
  // file processing and prediction
  //
  function checkAcceptedFiles(file) {
    file = file || {name: "unspecified"};
    dropzone.getAcceptedFiles().forEach(file => {
      if (file.dataURL
            && cxr.state.filesToProcess.indexOf(file) == -1) {
        status(`adding ${file.name}`);
        cxr.state.filesToProcess.unshift(file);
      }
    });
    triggerPrediction();
  }

  function predictFromBase64Image(name, rows, columns, imageString) {
    imageArray = Base64Binary.decode(imageString);
    cxr.imageMatrix = cv.matFromArray(rows, columns, cv.CV_8UC3, imageArray);
    cv.imshow('cxrCanvas', cxr.imageMatrix);
    predictFromImageSource(name, cxr.imageCanvas.toDataURL("image/png"));
  }

  function predictFromImageSource(name, imageSource) {
    cxr.imageElement.src = imageSource;
    cxr.state.predictingFile = {
      name: name,
      dataURL: cxr.imageElement.src,
    }
    cxr.imageElement.onload = function () {
      equalizeImageToCanvas()
      .then(predictResultFromCanvas);
    }
  }

  function equalizeImageToCanvas() {
    // uses global element and canvas
    return new Promise((resolve, reject) => {
      cxr.imageMatrix = cv.imread(cxr.imageElement); // TODO: normalize in cv
console.log(cv.mean(cxr.imageMatrix));
      const message = cvImageToMessageData(cxr.imageMatrix);
      cxr.imageMatrix.delete();
      message.request = "equalize";
      const worker = new Worker("worker.js");
      worker.addEventListener("message", (message) => {
        cxr.imageMatrix = messageDataToCvImage(message.data);
        cv.imshow('cxrCanvas', cxr.imageMatrix);

        //cxr.imageMatrix.delete(); TODO: delete this

        worker.terminate();
        message.data.cvImage = cxr.imageMatrix;
        resolve(message.data);
      });
      worker.postMessage(message);
    });
  }

  function predictResultFromCanvas(result) {
    status(`Predicting ${cxr.state.predictingFile.name}...`);
    //const tensor = tf.browser.fromPixels(cxr.imageCanvas).div(255);
    //const reshapedTensor = tensor.reshape([-1, cxr.imageElement.height, cxr.imageElement.width, 3]);
    console.log(result);
    const range = result.result.upper - result.result.lower;
    const shape = [1, cxr.imageElement.height, cxr.imageElement.width, 3];
    const imageTensor = tf.buffer(shape, "float32", result.cvImage.data32F).toTensor();
    cxr.imageTensorPre = imageTensor;
    imageTensor.sub(result.result.lower).mul(1./range).clipByValue(0, 1);
    cxr.imageTensorPost = imageTensor;
    predictionTensor = model.predict(imageTensor, {verbose: true})
    predictionTensor.data()
    .then(data => {
      finalizePrediction({
        name : cxr.state.predictingFile.name,
        headerText : `Results for: ${cxr.state.predictingFile.name}`,
        thumbnailSoure : cxr.state.predictingFile.dataURL,
        probabilities : {
          normal : data[0],
          mild : data[1],
          moderateSevere : data[2],
        }
      });
      cxr.state.filesProcessed.unshift(cxr.state.predictingFile);
      cxr.state.predictingFile = undefined;
      status(`Finished predicting`);
      checkAcceptedFiles();
    });
  }

  function finalizePrediction(prediction) {
    // create document structure
    const results = document.getElementById('cxrResults')
    const header = document.createElement("h3");
    results.appendChild(header);
    const reportThumbndail = document.createElement("img");
    reportThumbndail.width = 200
    results.appendChild(reportThumbndail);
    const reportGlyph = document.createElement("div");
    results.appendChild(reportGlyph);
    const resultTable = document.createElement("div");
    resultTable.setAttribute("class", "cxrResultTable");
    rows = {};
    Object.keys(prediction.probabilities).forEach( row => {
      rows[row] = document.createElement("p");
      resultTable.appendChild(rows[row]);
    });
    results.appendChild(resultTable);
    // fill in values
    header.innerText = prediction.headerText;
    reportThumbndail.src = prediction.thumbnailSoure;
    const keyMap = {
      normal : "normal",
      mild : "mild",
      moderateSevere : "moderate or severe",
    }
    Object.keys(prediction.probabilities).forEach( row => {
      rows[row].innerText = `${(100 * prediction.probabilities[row]).toFixed(2)}% probability of being ${keyMap[row]}`;
    });
    const greenWidth = 100*prediction.probabilities['normal'];
    const yellowWidth = 100*prediction.probabilities['mild'];
    const redWidth = 100*prediction.probabilities['moderateSevere'];
    reportGlyph.outerHTML += `
      <svg width="${reportThumbndail.width}" height="60" xmlns="http://www.w3.org/2000/svg">
        <rect x="0" y="0" width="100%" height="100%" fill = "black"></rect>
        <g transform="translate(100 30)">
        <g transform="scale(.9 .83)">
        <g transform="translate(-100 -30)">
          <rect x="0" y="0" width="${greenWidth}%" height="100%" fill="green"></rect>
          <rect x="${greenWidth}%" y="0" width="${yellowWidth}%" height="100%" fill="yellow"></rect>
          <rect x="${greenWidth + yellowWidth}%" y="0" width="${redWidth}%" height="100%" fill="red"></rect>
        </g> </g> </g>
      </svg>
    `;

    if (cxr.options.offerDownload) {
      const resultObject = {
        name: prediction.name,
        probabilities: prediction.probabilities,
      };
      cxr.imageCanvas.toBlob(pngBlob => {
        const resultBlob = new Blob([JSON.stringify(resultObject, null, 2)], {type: 'application/json'});
        let zip = new JSZip();
        zip.file(`${prediction.name}-result.json`, resultBlob);
        zip.file(`${prediction.name}-equalized.png`, pngBlob);
        zip.generateAsync({type: "blob"})
        .then(contents => {
          console.log(contents);
          saveAs(contents, `${prediction.name}-result.zip`);
        });
      }, 'image/png');
    }
  }

  function triggerPrediction() {
    if (cxr.state.predictingFile
          || cxr.state.filesToProcess.length == 0
          || !model
      ) {
      console.log('triggered, but nothing to predict');
      console.log('predicting', cxr.state.predictingFile);
      console.log('cxr.state.filesToProcess', cxr.state.filesToProcess);
      return;
    }
    const file = cxr.state.filesToProcess.pop();
    cxr.state.predictingFile = file;
    setTimeout(() => {
      cxr.imageElement.src = cxr.state.predictingFile.dataURL;
      cxr.imageElement.onload = function() {
        dropzone.removeFile(cxr.state.predictingFile);
        status(`Equalizing ${cxr.state.predictingFile.name}...`);
        equalizeImageToCanvas()
        .then(predictResultFromCanvas);
      }
    }, 5);
  }

  function status(message) {
    console.log(message);
    document.getElementById('cxrStatus').innerText = message;
  }

</script>

<script>
//
// code that needs to execute after document body is loaded
//
(function() {
  Dropzone.autoDiscover = false;
  dropzone = new Dropzone(cxr.dropzoneElement, {
    autoProcessQueue: true,
    parallelUploads: 1,
  });
  dropzone.on("error", checkAcceptedFiles);
})();
</script>

</body>
