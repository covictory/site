<head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161484045-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-161484045-1');
</script>


<link rel="stylesheet" href="site.css" />

<!-- Load TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.0"> </script>

<!-- Load thirdparty -->
<script src="thirdparty/FileSaver-v2.0.2.min.js"> </script>
<script src="thirdparty/base64-binary.js"> </script>
<script src="thirdparty/dropzone.min.js"> </script>
<script src="thirdparty/jszip.min.js"> </script>
<script src="thirdparty/magick.js"> </script>
<link rel="stylesheet" href="thirdparty/dropzone.min.css"/>

</head>

<body>

<div id="page">

<h1>Pneumonia Severity Prediction from Chest X-Ray (prototype)</h1>
<p>For informational use only. Not validated for any purpose.</p>

<img id="cxrLogo" src="skeleton.svg" width=100 height=100></img>

<h2 id="cxrStatus"></h2>

<form action="/file-upload"
      class="dropzone"
      id="cxrDropzone">
  <p class="dz-message">Drop chest X-ray image here, or click to upload (dcm, png, jpg...)</p>
</form>

<div id="cxrResults"></div>

<!-- for testing
<img id="cxrImage" hidden=true width=1024 height=1024></img>
<img id="cxrCanvas" hidden=true width=1024 height=1024></img>
 -->
<img id="cxrImage" width=1024 height=1024></img>
<canvas id="cxrCanvas" width=1024 height=1024></canvas>


<script>

  if (!window.Worker ||
      !window.tf ) {
    alert("This browser is not supported.  Share X ray photos with a computer that has a modern browser");
  }

  //
  // args and globals
  //
  //const modelName = "CheXNet_acil-tfjs";
  //const modelName = "modeltest-003-0.894167-0.769167.tfjs";
  //let modelName = "modeltest-003-0.886000-0.806667.tfjs";
  let modelName = "model-009-0.922879-0.799286.tfjs"
  let modelURL = `https://storage.googleapis.com/cxr-models/${modelName}/model.json`;
  let model;
  let magick;

  const cxr = {
    imageElement : document.getElementById('cxrImage'),
    imageCanvas : document.getElementById('cxrCanvas'),
    imageMatrix : undefined,
    dropzoneElement : document.getElementById('cxrDropzone'),
    state : {
      predictingFile : undefined,
      filesToProcess : [],
      filesProcessed : [],
    },
    options : {
      offerDownload : false,
    },
  };
  cxr.imageElement.crossOrigin = "Anonymous";

  const url = new URL(document.location.href);
  const searchParams = new URLSearchParams(url.search);
  if (searchParams.has("imageURL")) {
    // for example:
    // http://127.0.0.1:8080/?imageURL=https://storage.googleapis.com/cxr-data/chest-xray/test/PNEUMONIA/person100_bacteria_475.jpeg&offerDownload=true
    const imageURL = new URL(searchParams.get("imageURL"));
    const pathParts = imageURL.pathname.split("/")
    const name = pathParts[pathParts.length-1];
    predictFromImageSource(name, searchParams.get("imageURL"));
  }
  if (searchParams.has("modelURL")) {
    modelURL = searchParams.get("modelURL");
  }
  if (searchParams.has("offerDownload")) {
    if (searchParams.get("offerDownload") == "true") {
      cxr.options.offerDownload = true;
    }
  }

  //
  // model
  //
  status('Downloading predictive model');
  const modelLoadPromise = tf.loadLayersModel(modelURL, {
    onProgress: (fraction) => {status(`${(fraction * 100).toFixed(1)}% loaded...`);},
  });

  modelLoadPromise
  .then(loadedModel => {
    model = loadedModel;
    status("Model is ready");
    triggerPrediction()
  });

  //
  // magick
  //
  function onMagickDependenciesFullfilled() {
    console.log("Magick is ready");
    magick = Module;
    triggerPrediction();
  }

  //
  // file processing and prediction
  //
  function checkAcceptedFiles(file) {
    file = file || {name: "unspecified"};
    dropzone.files.forEach(file => {
      if (cxr.state.filesToProcess.indexOf(file) == -1) {
        status(`adding ${file.name}`);
        cxr.state.filesToProcess.unshift(file);
      }
    });
    triggerPrediction();
  }

  function predictFromBase64Image(name, rows, columns, imageString) {
    imageArray = Base64Binary.decode(imageString);
    predictFromImageSource(name, cxr.imageCanvas.toDataURL("image/png"));
  }

  function predictFromImageSource(name, imageSource) {
    cxr.imageElement.src = imageSource;
    cxr.state.predictingFile = {
      name: name,
      dataURL: cxr.imageElement.src,
    }
    cxr.imageElement.onload = function () {
      equalizeImageToFloatArray()
      .then(predictResultFromFloatArray);
    }
  }

  function equalizeImageToFloatArray(fileName, fileContents) {
    console.log(fileContents);
    return new Promise((resolve, reject) => {

      status(`Equalizing: preparing input ${fileName}`);
      FS.writeFile(fileName, fileContents, {encoding: "binary"});

      status('Equalizing: equalizing');
      const [imageWidth, imageHeight] = [1024, 1024];
      const sizeofFloat32 = 4;
      const imagePixelCount = imageWidth*imageHeight;
      const imageComponents = 3;
      const imageFloat32Count = imagePixelCount * imageComponents;
      const imageByteCount = imageFloat32Count * sizeofFloat32;
      const imageFilePath = `equalized_output.${imageComponents == 3 ? "rgb" : "gray"}`;

      const normalize = `-resize ${imageWidth}x${imageHeight}! -filter Lanczos`;
      const clahe = `-clahe 12.5x12.5%+256+10`;
      const median = `-median 3x3`;
      const clip = `-contrast-stretch 2%x2%`
      const dataType = `-define quantum:format=floating-point -depth 32`;
      const command = `${fileName} ${normalize} ${median} ${clip} ${dataType} ${imageFilePath}`;
      console.log('magick ' + command);

      magick.run(command.split(" "));

      status('Equalizing: making pixelarray');
      const bytes = new Uint8Array(imageByteCount);
      const stream = FS.open(imageFilePath, "r");
      FS.read(stream, bytes, 0, imageByteCount);
      FS.close(stream);
      floatArray = new Float32Array(bytes.buffer);
      pixelArray = new Uint8ClampedArray(floatArray.byteLength);

      /* TODO:
      for (let row = 0; row < imageHeight; ++row) {
        for (let column = 0; column < imageWidth; ++column) {
          const value = floatArray[(row*imageWidth + column) * imageComponents] * 255;
          let index = (row*imageWidth + column) * 4;
          pixelArray[index]   = value;    // red
          pixelArray[++index] = value;    // green
          pixelArray[++index] = value;    // blue
          pixelArray[++index] = 255;      // alpha
        }
      }
      */
      status('Equalizing: resolving');

      resolve({floatArray, pixelArray});
    });
  }

  function predictResultFromFloatArray(result) {
    status(`Predicting ${cxr.state.predictingFile.name}...`);
    const shape = [1, cxr.imageElement.height, cxr.imageElement.width, 3];
    const imageTensor = tf.buffer(shape, "float32", result.floatArray).toTensor();
    predictionTensor = model.predict(imageTensor, {verbose: true})
    predictionTensor.data()
    .then(data => {
      finalizePrediction({
        name : cxr.state.predictingFile.name,
        headerText : `Results for: ${cxr.state.predictingFile.name}`,
        thumbnailSoure : cxr.state.predictingFile.dataURL,
        probabilities : {
          normal : data[0],
          mild : data[1],
          moderateSevere : data[2],
        }
      });
      cxr.state.filesProcessed.unshift(cxr.state.predictingFile);
      cxr.state.predictingFile = undefined;
      status(`Finished predicting`);
      checkAcceptedFiles();
    });
  }

  function finalizePrediction(prediction) {
    // create document structure
    const results = document.getElementById('cxrResults')
    const header = document.createElement("h3");
    results.appendChild(header);
    const reportThumbndail = document.createElement("img");
    reportThumbndail.width = 200
    results.appendChild(reportThumbndail);
    const reportGlyph = document.createElement("div");
    results.appendChild(reportGlyph);
    const resultTable = document.createElement("div");
    resultTable.setAttribute("class", "cxrResultTable");
    rows = {};
    Object.keys(prediction.probabilities).forEach( row => {
      rows[row] = document.createElement("p");
      resultTable.appendChild(rows[row]);
    });
    results.appendChild(resultTable);
    // fill in values
    header.innerText = prediction.headerText;
    reportThumbndail.src = prediction.thumbnailSoure;
    const keyMap = {
      normal : "normal",
      mild : "mild",
      moderateSevere : "moderate or severe",
    }
    Object.keys(prediction.probabilities).forEach( row => {
      rows[row].innerText = `${(100 * prediction.probabilities[row]).toFixed(2)}% probability of being ${keyMap[row]}`;
    });
    const greenWidth = 100*prediction.probabilities['normal'];
    const yellowWidth = 100*prediction.probabilities['mild'];
    const redWidth = 100*prediction.probabilities['moderateSevere'];
    reportGlyph.outerHTML += `
      <svg width="${reportThumbndail.width}" height="60" xmlns="http://www.w3.org/2000/svg">
        <rect x="0" y="0" width="100%" height="100%" fill = "black"></rect>
        <g transform="translate(100 30)">
        <g transform="scale(.9 .83)">
        <g transform="translate(-100 -30)">
          <rect x="0" y="0" width="${greenWidth}%" height="100%" fill="green"></rect>
          <rect x="${greenWidth}%" y="0" width="${yellowWidth}%" height="100%" fill="yellow"></rect>
          <rect x="${greenWidth + yellowWidth}%" y="0" width="${redWidth}%" height="100%" fill="red"></rect>
        </g> </g> </g>
      </svg>
    `;

    if (cxr.options.offerDownload) {
      const resultObject = {
        name: prediction.name,
        probabilities: prediction.probabilities,
      };
      cxr.imageCanvas.toBlob(pngBlob => {
        const resultBlob = new Blob([JSON.stringify(resultObject, null, 2)], {type: 'application/json'});
        let zip = new JSZip();
        zip.file(`${prediction.name}-result.json`, resultBlob);
        zip.file(`${prediction.name}-equalized.png`, pngBlob);
        zip.generateAsync({type: "blob"})
        .then(contents => {
          console.log(contents);
          saveAs(contents, `${prediction.name}-result.zip`);
        });
      }, 'image/png');
    }
  }

  function triggerPrediction() {
    if (cxr.state.predictingFile
          || cxr.state.filesToProcess.length == 0
          || !model
          || !magick
      ) {
      console.log('triggered, but nothing to predict');
      console.log('predicting', cxr.state.predictingFile);
      console.log('cxr.state.filesToProcess', cxr.state.filesToProcess);
      return;
    }
    const file = cxr.state.filesToProcess.pop();
    cxr.state.predictingFile = file;
    console.log(file);
    const fileReader = new FileReader();
    fileReader.readAsArrayBuffer(file);
    fileReader.addEventListener('progress', (event) => {
      status(`${event.loaded} bytes loaded`);
    });
    fileReader.addEventListener('loadend', (event) => {
      dropzone.removeFile(cxr.state.predictingFile);
      cxr.imageElement.src = cxr.state.predictingFile.dataURL;
      const fileName = cxr.state.predictingFile.name;
      status(`Equalizing ${fileName}...`);
      const fileContents = new Uint8Array(event.target.result);

      // TODO: pngtoy?
      if (fileName.endsWith(".png")) {
        window.fileContents = fileContents;
      }

      equalizeImageToFloatArray(fileName, fileContents)
      .then(predictResultFromFloatArray);
    });
  }

  function status(message) {
    console.log(message);
    document.getElementById('cxrStatus').innerText = message;
  }

</script>

<script>
//
// code that needs to execute after document body is loaded
//
(function() {
  Dropzone.autoDiscover = false;
  dropzone = new Dropzone(cxr.dropzoneElement, {
    autoProcessQueue: true,
    parallelUploads: 1,
  });
  dropzone.on("error", checkAcceptedFiles);
})();
</script>

</body>
